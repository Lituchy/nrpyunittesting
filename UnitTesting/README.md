## NRPy Unit Testing: An In-Depth Guide

### Motivation:

What is the purpose of unit testing, and why should you do it? To begin
thinking about that, consider what subtleties can occur within your code
that are almost unnoticeable to the eye, but wind up giving you an
incorrect result. You could make a small optimization, and not notice
any change in your result. However, maybe the optimization you made only
works on Python 3 and not Python 2, or it changes a value by some tiny
amount -- too small to be noticeable at a simple glance, but enough to
make a difference in succeeding calculations.

This is where unit testing comes in. By initially calculating values for
the globals of your modules in a **trusted** version of your code and
storing those values in a dictionary, you can then easily check if
something stopped working correctly by comparing your newly calculated
values to the ones you've stored. On the frontend, there are three
concepts essential to understand to get your unit tests up and running:
`trusted_values_dict`, `create_test`, and your testing module (which
will simply be referred to as `test_file`). The usage of each of these
modules is outlined in the Beginning section. There is also some
important prerequisite knowledge that may be helpful to grasp before
beginning your testing. There are many functions at play in the backend
as well, all of which will be described in detail below in the
Functions section. Mastery of these functions may not be
essential to get your tests up-and-running, but some basic understanding
of them with undoubtedly help with debugging.

An important caveat is that the unit testing does not test the
**correctness** of your code or your variables. The unit tests act as a
protective measure to ensure that nothing was broken between versions of
your code; it gets its values by running _your_ code, so if something
starts out incorrect, it will be stored as incorrect in the system.


### Beginning: 

#### Getting started:

This section will give the user a low-level instructions outlining how
to create their own unit tests at the most basic level. Much more
in-depth instructions and ideas will be discussed in sections below and
are recommended if the user will be doing any complex tests. We will
follow the NRPy unit testing naming scheme in the tutorial below.

To begin unit testing, create a directory in the module being tested
called 'tests'. This will be the directory that houses all the tests for
the given module, as well as the trusted_values_dict. Create a file in
this directory called 'test_(your module name)'. This will be the file
where you, the user, tells our infrastructure what tests to run. This
file will initially be empty. Copy over the code from
'UnitTesting/test_skeleton.py' into your test file. It contains a basic
overview of what has to be filled in. Fill in 'module', 'module_name',
and 'function_and_global_dict' according to the following concept:

`module` contains a string representation of what the user would type if
they were trying to import `module`. For example, if the user is wanting
to test a module `BrillLindquist` in directory `BSSN` they may say `
import BSSN.BrillLindquist as bl`. So, `module` should contain what the
user is importing -- so in this case, `BSSN.BrillLindquist`.

`module_name` is a string of whatever the user would like their module
to be referenced as in their trusted_values_dict. In the example above,
the user may set `module_name` to `BrillLindquist` or `bl`.

`function_and_global_dict` is a Python dictionary whose keys are string
representations of function calls to be enacted on `module`, and whose
values are lists of string representations of globals that are created
after the function is called. Using the same example as above,
`function` may be `'BrillLindquist(ComputeADMGlobalsOnly = False)'` and
the list of globals may be `['alphaCart', 'betaCartU', 'BCartU',
'gammaCartDD', 'KCartDD']`. Then by extension,
`function_and_global_dict` would be
`{'BrillLindquist(ComputeADMGlobalsOnly = False)': ['alphaCart',
'betaCartU', 'BCartU', 'gammaCartDD', 'KCartDD']}`

Finally, `create_test` is called on these arguments, and the test will
run. For much more in-depth information on unit testing and creating
better tests, reading on is **strongly** encouraged.

#### trusted_values_dict:
A trusted_values_dict is a structure we use in NRPy Unit Testing whereby
the globals generated by a specific function call in a given module are
given random, yet deterministic, values that can be compared to
themselves in future versions of code. For example, consider BSSN. It
contains multiple modules, each with their own unique functions and
globals. BSSN gets its own trusted_values_dict that stores every global
for each function call for each module in BSSN. A simple example
trusted_values_dict is as follows:

```
from mpmath import mpf, mp, mpc
from UnitTesting.standard_constants import precision

mp.dps = precision
trusted_values_dict = {}

# Generated on: 2019-08-07
trusted_values_dict['Module_1__Function_1__globals'] = {'alpha': mpf(0.0), 'betaU[0]': mpf(1.0), 'betaU[1]': mpf(0.0), 'betaU[2]': mpf('-0.0742854979156755661927481235464') }

# Generated on: 2019-08-07
trusted_values_dict['Module_1__Function_2__globals'] = {'phi': mpf('0.414786900166179080948286822502')

# Generated on: 2019-08-08
trusted_values_dict['Module_2__Func__globals'] = {'gamma': mpf('0.416727599713016316762548285624'), 'delta': mpc(real='0.0', imag='1.0')  }

```

Each entry in the trusted_values_dict follows the naming scheme (module
name)__(function)__globals. The values are of type mpf or mpc, depending
on if the result was complex or not. Let's take a close look at the
entries relating to 'betaU' for 'Module_1__Function_1__globals'. As we
can see, its three values -- betaU\[0], betaU\[1], betaU\[2] -- are all
given their own entry in the dict. This makes it much easier for the
user to debug an issue when a variable has a differing value from the
trusted version; the user gets told exactly which indices of which
variables have the error.

#### create_test:
create_test is a function that takes the following user-supplied
information: a module to test `module`, the name of the module
`module_name`, and a dictionary whose keys are functions and whose
values are lists of globals `function_and_global_dict`. It uses this
information to generate a test file that is automatically run as a bash
script; this test file does all the heavy lifting in calling the
function, getting expressions for all the globals, evaluating the
expressions to numerical values, and storing the values in the proper
trusted_values_dict.

create_test additionally takes optional arguments `logging_level` and
`initialization_string_dict`, which respectively determine the desired
level of output (think verbosity) and run some python code prior calling
the specified function. Usage is as following:

```
module = 'BSSN.BrillLindquist'

module_name = 'BrillLindquist'

function_and_global_dict = {'BrillLindquist(ComputeADMGlobalsOnly = True)': ['alphaCart', 'betaCartU', 'BCartU', 'gammaCartDD', 'KCartDD']}

create_test(module, module_name, function_and_global_dict)
```

The way to think of this is that the module to be tested is
BSSN.BrillLindquist. The module_name is how you refer to this module --
it's a bit arbitrary, so whether you prefer BrillLindquist or bl, it
won't change the computation. The function_and_global_dict contains
entry 'BrillLindquist(ComputeADMGlobalsOnly = True)', which is the
function that gets called in the module. It's value in the dictionary is
a list of globals that get created when this function gets called.

Now let's add the optional arguments into the same example:

```
module = 'BSSN.BrillLindquist'

module_name = 'BrillLindquist'

function_and_global_dict = {'BrillLindquist(ComputeADMGlobalsOnly = True)': ['alphaCart', 'betaCartU', 'BCartU', 'gammaCartDD', 'KCartDD']}

logging_level = 'DEBUG'

initialization_string_dict = {'BrillLindquist(ComputeADMGlobalsOnly = True)': 'print("example")\nprint("Hello world!")'}

create_test(module, module_name, function_and_global_dict, logging_level=logging_level, initialization_string_dict=initialization_string_dict)
```

Now when create_test runs, the user will be given much more output due
to the logging_level; additionally, the user-specified print will occur
due to initialization_string_dict.

You may now be wondering why we use dictionaries to store this data
instead of simply having separate variables `function`, `global_list`,
and `initialization_string`. This is where some of the power of this
testing method lies: we can test multiple functions and their globals
with ease! In other words, function_and_global_dict can contain multiple
entries, each a specific function call with its own associated list of
globals. Since not every function being tested must have an associated
initialization_string, we make an entry for each function optional. An
example is as follows:

```
module = 'BSSN.BrillLindquist'

module_name = 'BrillLindquist'

function_and_global_dict = {'BrillLindquist(ComputeADMGlobalsOnly = True)': ['alphaCart', 'betaCartU', 'BCartU', 'gammaCartDD', 'KCartDD'],
                            'BrillLindquist(ComputeADMGlobalsOnly = False)': ['alphaCart', 'betaCartU', 'BCartU', 'gammaCartDD', 'KCartDD']}

logging_level = 'DEBUG'

initialization_string_dict = {'BrillLindquist(ComputeADMGlobalsOnly = True)': 'print("example")\nprint("Hello world!")'}

create_test(module, module_name, function_and_global_dict, logging_level=logging_level, initialization_string_dict=initialization_string_dict)
```

Both instances will be called separately, with their own globals. The
print statements will only be called in the first function, since there
is no associated initialization_string for the second function as well.

An important note when using `create_test` is that all arguments are
**strings**. This includes the module, module_name, function, each
global in the list of globals, logging level, and initialization_string.
The reason for making these fields strings is that when setting
module_name, for example, there doesn't exist anything in Python with
the name BrillLindquist. So, we wrap it in a string. This is true of
every input. Be careful with the dicts and lists, however: their
arguments are strings, they aren't themselves strings.

### In-depth Explanations:

